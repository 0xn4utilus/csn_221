$date
	Thu Oct 20 02:49:08 2022
$end
$version
	Icarus Verilog
$end
$timescale
	1ns
$end
$scope module testbench $end
$var wire 32 ! branchOffset [31:0] $end
$var wire 1 " branchPresent $end
$var wire 1 # write $end
$var wire 32 $ instruction [31:0] $end
$var wire 32 % PC [31:0] $end
$var reg 1 & clk $end
$scope module instructionFetch $end
$var wire 32 ' branchOffset [31:0] $end
$var wire 1 " branchPresent $end
$var wire 1 & clk $end
$var wire 1 ( start $end
$var wire 1 # write $end
$var wire 32 ) instruction [31:0] $end
$var wire 32 * PC [31:0] $end
$var reg 32 + PCReg [31:0] $end
$var reg 32 , newPCreg [31:0] $end
$scope module instructionMem $end
$var wire 32 - PC [31:0] $end
$var wire 32 . instruction [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b10000110000100000100000 .
b0 -
b0 ,
b100 +
b0 *
b10000110000100000100000 )
1(
b0 '
1&
b0 %
b10000110000100000100000 $
1#
0"
b0 !
$end
#50
b10000110000100000100010 $
b10000110000100000100010 )
b10000110000100000100010 .
b100 %
b100 *
b100 ,
b100 -
0&
#100
b1000 +
1&
#150
b11000100000100000100000 $
b11000100000100000100000 )
b11000100000100000100000 .
b1000 %
b1000 *
b1000 ,
b1000 -
0&
#200
b1100 +
1&
#250
bx $
bx )
bx .
b1100 %
b1100 *
b1100 ,
b1100 -
0&
